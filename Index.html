<!DOCTYPE html><html lang="en"> <head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Lens Lab — Distortion + Watermarks (Local Only)</title> <style> :root{ --bg:#0f1218; --panel:#171b23; --card:#1b202a; --accent:#7aa2ff; --muted:#8a94a7; --text:#e7eefc; --text-soft:#c6cfdf; --ok:#2ecc71; --warn:#f39c12; --bad:#e74c3c; } html,body{height:100%;background:linear-gradient(180deg,#0f1218,#0c1016);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;} *{box-sizing:border-box} header{display:flex;justify-content:space-between;align-items:center;padding:16px 20px;border-bottom:1px solid #222832;background:rgba(15,18,24,.75);backdrop-filter: blur(6px);position:sticky;top:0;z-index:10} header .brand{display:flex;gap:10px;align-items:center} .logo{width:28px;height:28px;border-radius:8px;background: conic-gradient(from 180deg at 50% 50%, #23314d 0deg, #1f2645 120deg, #243a73 240deg, #23314d 360deg);box-shadow:0 6px 18px rgba(122,162,255,.3)} .title{font-weight:700;letter-spacing:.3px} .sub{font-size:12px;color:var(--muted)} .layout{display:grid;grid-template-columns:320px 1fr;gap:16px;max-width:1400px;margin:18px auto;padding:0 16px} @media(max-width:1000px){.layout{grid-template-columns:1fr}} aside.panel{background:var(--panel);border:1px solid #202635;border-radius:14px;padding:14px;display:flex;flex-direction:column;gap:12px} .group{background:var(--card);border:1px solid #222a3a;border-radius:12px;padding:12px} .group h3{margin:.2rem 0 .8rem 0;font-size:14px;color:var(--text-soft);letter-spacing:.2px} .row{display:flex;align-items:center;gap:10px;margin:8px 0} .row label{font-size:13px;color:var(--text-soft);min-width:118px} input[type="range"]{width:100%} input[type="color"]{border:none;background:#0000} input[type="text"],input[type="number"],select{background:#121722;color:var(--text);border:1px solid #2a3242;border-radius:8px;padding:8px 10px;width:100%} button{appearance:none;background:#1f2736;color:var(--text);border:1px solid #2a3242;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer;transition:.16s} button:hover{border-color:#3a4660;transform:translateY(-1px)} button.primary{background:linear-gradient(180deg,#2b3860,#263154);border-color:#34406a;color:#edf3ff} button.ghost{background:#151a24} button.warn{background:linear-gradient(180deg,#503515,#3d2a10);border-color:#5c3a12;color:#ffd9a6} button.bad{background:linear-gradient(180deg,#4a1820,#3a1219);border-color:#5c1c26;color:#ffd2d8} .stage{display:flex;flex-direction:column;gap:10px} .canvasWrap{position:relative;background:#0b0f16;border:1px solid #1b2230;border-radius:14px;overflow:hidden;min-height:360px;display:flex;align-items:center;justify-content:center} canvas{display:block;max-width:100%;height:auto} .dropzone{position:absolute;inset:0;border:2px dashed #2a3242;border-radius:14px;display:flex;align-items:center;justify-content:center;color:var(--muted);opacity:.7;pointer-events:none;transition:.18s} .dropzone.active{border-color:var(--accent);color:#cfe0ff;background:rgba(122,162,255,.06);opacity:1} .overlayHelp{position:absolute;bottom:10px;left:10px;background:rgba(18,23,34,.6);border:1px solid #2a3242;border-radius:8px;padding:6px 8px;color:#c6cfdf;font-size:12px} .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between} .leftBtns,.rightBtns{display:flex;gap:8px;flex-wrap:wrap} .hint{font-size:12px;color:var(--muted)} .kicker{font-size:12px;color:#aab7d3;margin-left:6px} footer{color:#9fb0cd;font-size:12px;opacity:.9;max-width:1400px;margin:12px auto 30px;padding:0 16px} .badge{display:inline-flex;align-items:center;gap:6px;background:#141a26;border:1px solid #223050;border-radius:999px;padding:6px 10px;font-size:12px;color:#cfdaf5} .pill{display:inline-flex;gap:8px;align-items:center;background:#121722;border:1px solid #253049;border-radius:999px;padding:4px 10px;font-size:12px;color:#b9c6e3} .legend{font-size:12px;color:#8ea0c2;margin:6px 0 0} .disclaimer{font-size:12px;color:#90a0bd;line-height:1.5;background:#121722;border:1px dashed #313a52;border-radius:10px;padding:10px;margin-top:8px} .small{font-size:11px;color:#95a3bf} </style> </head> <body> <header> <div class="brand"> <div class="logo"></div> <div> <div class="title">Lens Lab</div> <div class="sub">Local-only distortion + watermark studio</div> </div> </div> <div class="pill">No uploads • Works offline</div> </header><main class="layout"> <aside class="panel"> <div class="group"> <h3>Source</h3> <div class="row"> <input id="fileInput" type="file" accept="image/*,video/*" /> </div> <div class="row"> <button id="clearBtn" class="ghost">Clear</button> <span class="kicker" id="srcInfo">No media loaded</span> </div> <div class="disclaimer"> - Drag & drop media onto the preview.<br/> - Nothing is uploaded. Everything runs in your browser. </div> </div>
text

<div class="group">
  <h3>Lens Effect</h3>
  <div class="row">
    <label for="mode">Type</label>
    <select id="mode">
      <option value="none">None</option>
      <option value="barrel" selected>Barrel/Pincushion</option>
      <option value="fisheye">Fisheye (bulge/pinch)</option>
    </select>
  </div>

  <div id="barrelControls">
    <div class="row"><label>Strength (k1)</label><input id="k1" type="range" min="-1" max="1" step="0.01" value="-0.24"></div>
    <div class="row"><label>Curvature (k2)</label><input id="k2" type="range" min="-1" max="1" step="0.01" value="-0.10"></div>
    <div class="row"><label>Zoom</label><input id="zoom" type="range" min="1" max="3" step="0.01" value="1.15"></div>
  </div>

  <div id="fishControls" style="display:none">
    <div class="row"><label>Strength</label><input id="fishAmount" type="range" min="-1" max="1" step="0.01" value="0.45"></div>
    <div class="row"><label>Zoom</label><input id="fishZoom" type="range" min="1" max="3" step="0.01" value="1.1"></div>
  </div>

  <div class="row">
    <label>Center X</label><input id="centerX" type="range" min="0" max="1" step="0.001" value="0.5">
  </div>
  <div class="row">
    <label>Center Y</label><input id="centerY" type="range" min="0" max="1" step="0.001" value="0.5">
  </div>

  <div class="row">
    <button id="ringPreset" class="primary">Approx. Ring</button>
    <button id="resetLens" class="ghost">Reset</button>
  </div>
  <div class="legend">Tip: Hold Shift and drag on the canvas to set the distortion center.</div>
</div>

<div class="group">
  <h3>Watermarks</h3>
  <div class="row"><label><input type="checkbox" id="wmAI" /> AI-style corner tag</label></div>
  <div class="row"><label><input type="checkbox" id="wmBody" /> Bodycam-style overlay</label></div>

  <hr style="border:none;border-top:1px solid #273148;margin:10px 0">

  <div class="row"><label>Text</label><input id="wmText" type="text" placeholder="Enter watermark text"></div>
  <div class="row"><label>Size</label><input id="wmSize" type="range" min="10" max="120" step="1" value="28"></div>
  <div class="row"><label>Opacity</label><input id="wmAlpha" type="range" min="0" max="1" step="0.01" value="0.8"></div>
  <div class="row"><label>Color</label><input id="wmColor" type="color" value="#ffffff"></div>
  <div class="row">
    <label>Position</label>
    <select id="wmPos">
      <option value="tr">Top-Right</option>
      <option value="tl">Top-Left</option>
      <option value="br" selected>Bottom-Right</option>
      <option value="bl">Bottom-Left</option>
      <option value="c">Center</option>
    </select>
  </div>

  <hr style="border:none;border-top:1px solid #273148;margin:10px 0">

  <div class="row"><label>Image WM</label><input id="wmImg" type="file" accept="image/*"></div>
  <div class="row"><label>Scale</label><input id="wmImgScale" type="range" min="0.05" max="1.5" step="0.01" value="0.35"></div>
  <div class="row"><label>Opacity</label><input id="wmImgAlpha" type="range" min="0" max="1" step="0.01" value="0.85"></div>
  <div class="row">
    <label>Position</label>
    <select id="wmImgPos">
      <option value="tr">Top-Right</option>
      <option value="tl">Top-Left</option>
      <option value="br" selected>Bottom-Right</option>
      <option value="bl">Bottom-Left</option>
      <option value="c">Center</option>
    </select>
  </div>

  <div class="disclaimer">
    Use responsibly: avoid impersonation or misleading edits. Customize text or upload your own logo.
  </div>
</div>
</aside> <section class="stage"> <div class="canvasWrap" id="canvasWrap"> <canvas id="finalCanvas"></canvas> <canvas id="glCanvas" style="display:none"></canvas> <div class="dropzone" id="dropzone">Drop image/video here</div> <div class="overlayHelp">Shift + drag to set distortion center</div> </div> <div class="toolbar"> <div class="leftBtns"> <button id="playPause">Play</button> <button id="exportPng" class="primary">Export PNG</button> <button id="startRec" class="warn">Start Recording</button> <button id="stopRec" class="bad" disabled>Stop Recording</button> </div> <div class="rightBtns"> <span class="badge" id="statusBadge">Ready</span> <span class="hint" id="dimInfo"></span> </div> </div> </section> </main><footer> <div>Tip: Host this as index.html on GitHub Pages for easy sharing.</div> </footer><script> // State const state = { src: null, // HTMLImageElement or HTMLVideoElement isVideo: false, srcURL: null, width: 1280, height: 720, // Lens params mode: 'barrel', // none|barrel|fisheye k1: -0.24, k2: -0.10, zoom: 1.15, fishAmount: 0.45, fishZoom: 1.1, centerX: 0.5, centerY: 0.5, // Watermarks wmAI: false, wmBody: false, wmText: '', wmSize: 28, wmAlpha: 0.8, wmColor: '#ffffff', wmPos: 'br', wmImg: null, wmImgScale: 0.35, wmImgAlpha: 0.85, wmImgPos: 'br', // Playback & export playing: false, recording: false, mediaRecorder: null, recordedChunks: [], }; // Elements const fileInput = document.getElementById('fileInput'); const clearBtn = document.getElementById('clearBtn'); const srcInfo = document.getElementById('srcInfo'); const dropzone = document.getElementById('dropzone'); const canvasWrap = document.getElementById('canvasWrap'); const finalCanvas = document.getElementById('finalCanvas'); const glCanvas = document.getElementById('glCanvas'); const statusBadge = document.getElementById('statusBadge'); const dimInfo = document.getElementById('dimInfo'); const modeSel = document.getElementById('mode'); const barrelControls = document.getElementById('barrelControls'); const fishControls = document.getElementById('fishControls'); const k1 = document.getElementById('k1'); const k2 = document.getElementById('k2'); const zoom = document.getElementById('zoom'); const fishAmount = document.getElementById('fishAmount'); const fishZoom = document.getElementById('fishZoom'); const centerX = document.getElementById('centerX'); const centerY = document.getElementById('centerY'); const ringPresetBtn = document.getElementById('ringPreset'); const resetLensBtn = document.getElementById('resetLens'); const wmAI = document.getElementById('wmAI'); const wmBody = document.getElementById('wmBody'); const wmText = document.getElementById('wmText'); const wmSize = document.getElementById('wmSize'); const wmAlpha = document.getElementById('wmAlpha'); const wmColor = document.getElementById('wmColor'); const wmPos = document.getElementById('wmPos'); const wmImg = document.getElementById('wmImg'); const wmImgScale = document.getElementById('wmImgScale'); const wmImgAlpha = document.getElementById('wmImgAlpha'); const wmImgPos = document.getElementById('wmImgPos'); const playPauseBtn = document.getElementById('playPause'); const exportPngBtn = document.getElementById('exportPng'); const startRecBtn = document.getElementById('startRec'); const stopRecBtn = document.getElementById('stopRec'); // 2D context for final composite const outCtx = finalCanvas.getContext('2d'); // WebGL setup for lens effect const gl = glCanvas.getContext('webgl', { preserveDrawingBuffer: true, alpha: false, antialias: true }); if (!gl){ alert('WebGL not supported in this browser.'); } const vsSource = ` attribute vec2 a_position; attribute vec2 a_texCoord; varying vec2 v_texCoord; void main(){ v_texCoord = a_texCoord; gl_Position = vec4(a_position, 0.0, 1.0); } `; const fsSource = ` precision mediump float; varying vec2 v_texCoord; uniform sampler2D u_image; uniform vec2 u_texRes; uniform vec2 u_center; uniform float u_k1; uniform float u_k2; uniform float u_zoom; uniform float u_mode; // 0 none, 1 barrel, 2 fisheye uniform float u_fishAmt; uniform float u_fishZoom; vec4 sampleSafe(vec2 uv){ if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0){ return vec4(0.0,0.0,0.0,1.0); } return texture2D(u_image, uv); } void main(){ vec2 uv = v_texCoord; if (u_mode < 0.5){ gl_FragColor = sampleSafe(uv); return; } float aspect = u_texRes.x / u_texRes.y; vec2 c = u_center; vec2 p = uv - c; p.x *= aspect; vec2 pWarp = p; if (u_mode > 0.5 && u_mode < 1.5){ // Barrel/pincushion float r2 = dot(p,p); float f = 1.0 + u_k1 * r2 + u_k2 * r2 * r2; pWarp = p * f; pWarp.x /= aspect; vec2 wuv = c + pWarp; vec2 zuv = (wuv - c) / u_zoom + c; gl_FragColor = sampleSafe(zuv); return; } // Fisheye (bulge/pinch via power curve of radius) float r = length(p); vec2 dir = r > 1e-6 ? p / r : vec2(0.0); // Map radius using a power curve. Positive -> bulge (fisheye), Negative -> pinch float amt = u_fishAmt; // -1..1 float powK = 1.0 + amt * 0.9; // modest range float rn = pow(r, powK); pWarp = dir * rn; pWarp.x /= aspect; vec2 wuv = c + pWarp; vec2 zuv = (wuv - c) / u_fishZoom + c; gl_FragColor = sampleSafe(zuv); } `; function createShader(type,src){ const sh = gl.createShader(type); gl.shaderSource(sh, src); gl.compileShader(sh); if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(sh)); return null; } return sh; } function createProgram(vsSrc, fsSrc){ const vs = createShader(gl.VERTEX_SHADER, vsSrc); const fs = createShader(gl.FRAGMENT_SHADER, fsSrc); const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog); if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(prog)); return null; } return prog; } const program = createProgram(vsSource, fsSource); gl.useProgram(program); const attribPos = gl.getAttribLocation(program, 'a_position'); const attribUV = gl.getAttribLocation(program, 'a_texCoord'); const uImage = gl.getUniformLocation(program, 'u_image'); const uTexRes = gl.getUniformLocation(program, 'u_texRes'); const uCenter = gl.getUniformLocation(program, 'u_center'); const uK1 = gl.getUniformLocation(program, 'u_k1'); const uK2 = gl.getUniformLocation(program, 'u_k2'); const uZoom = gl.getUniformLocation(program, 'u_zoom'); const uMode = gl.getUniformLocation(program, 'u_mode'); const uFishAmt = gl.getUniformLocation(program, 'u_fishAmt'); const uFishZoom = gl.getUniformLocation(program, 'u_fishZoom'); // Fullscreen quad const quadBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer); // 2 triangles: position(x,y), uv(u,v) const verts = new Float32Array([ -1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, -1, 1, 0, 1, 1, -1, 1, 0, 1, 1, 1, 1 ]); gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW); gl.enableVertexAttribArray(attribPos); gl.vertexAttribPointer(attribPos, 2, gl.FLOAT, false, 16, 0); gl.enableVertexAttribArray(attribUV); gl.vertexAttribPointer(attribUV, 2, gl.FLOAT, false, 16, 8); // Texture const tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.uniform1i(uImage, 0); // Helpers function updateStatus(msg, kind='info'){ statusBadge.textContent = msg; statusBadge.style.borderColor = kind === 'bad' ? '#5c1c26' : (kind==='warn' ? '#5c3a12' : '#223050'); } function setCanvasSize(w, h){ state.width = w; state.height = h; const wrapW = canvasWrap.clientWidth; const wrapH = Math.max(360, Math.round(wrapW * h / w)); glCanvas.width = w; glCanvas.height = h; gl.viewport(0, 0, w, h); finalCanvas.width = w; finalCanvas.height = h; finalCanvas.style.width = '100%'; finalCanvas.style.height = 'auto'; dimInfo.textContent = `${w}×${h}`; } function loadFile(file){ if (!file) return; if (state.srcURL) URL.revokeObjectURL(state.srcURL); const url = URL.createObjectURL(file); state.srcURL = url; if (file.type.startsWith('video/')){ const v = document.createElement('video'); v.src = url; v.loop = true; v.muted = true; v.playsInline = true; v.crossOrigin = 'anonymous'; v.addEventListener('loadedmetadata', ()=>{ setCanvasSize(v.videoWidth || 1280, v.videoHeight || 720); state.src = v; state.isVideo = true; updateStatus('Video loaded'); srcInfo.textContent = `${file.name} (${Math.round(file.size/1024)} KB)`; // Autoplay for convenience v.play().then(()=>{ state.playing = true; playPauseBtn.textContent='Pause'; }).catch(()=>{}); }); v.addEventListener('error', ()=>updateStatus('Video failed to load','bad')); }else if (file.type.startsWith('image/')){ const img = new Image(); img.crossOrigin = 'anonymous'; img.onload = ()=>{ setCanvasSize(img.naturalWidth || 1280, img.naturalHeight || 720); state.src = img; state.isVideo = false; state.playing = false; updateStatus('Image loaded'); srcInfo.textContent = `${file.name} (${Math.round(file.size/1024)} KB)`; playPauseBtn.textContent = 'Play'; }; img.onerror = ()=>updateStatus('Image failed to load','bad'); img.src = url; }else{ updateStatus('Unsupported file type','bad'); } } fileInput.addEventListener('change', e=>{ if (e.target.files && e.target.files[0]) loadFile(e.target.files[0]); }); // Drag & drop ;['dragenter','dragover'].forEach(evt=>{ canvasWrap.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); dropzone.classList.add('active'); }); }); ;['dragleave','dragend','drop'].forEach(evt=>{ canvasWrap.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('active'); }); }); canvasWrap.addEventListener('drop', e=>{ const file = e.dataTransfer.files && e.dataTransfer.files[0]; if (file) loadFile(file); }); clearBtn.addEventListener('click', ()=>{ if (state.srcURL) URL.revokeObjectURL(state.srcURL); state.srcURL = null; state.src = null; state.isVideo = false; state.playing = false; outCtx.clearRect(0,0,finalCanvas.width, finalCanvas.height); srcInfo.textContent = 'No media loaded'; playPauseBtn.textContent = 'Play'; }); // Controls modeSel.addEventListener('change', ()=>{ state.mode = modeSel.value; barrelControls.style.display = state.mode === 'barrel' ? '' : 'none'; fishControls.style.display = state.mode === 'fisheye' ? '' : 'none'; }); function bindRange(el, key, parse=(v)=>+v){ el.addEventListener('input', ()=>{ state[key] = parse(el.value); }); } bindRange(k1, 'k1'); bindRange(k2, 'k2'); bindRange(zoom, 'zoom'); bindRange(fishAmount, 'fishAmount'); bindRange(fishZoom, 'fishZoom'); bindRange(centerX, 'centerX'); bindRange(centerY, 'centerY'); ringPresetBtn.addEventListener('click', ()=>{ modeSel.value = 'barrel'; modeSel.dispatchEvent(new Event('change')); state.k1 = -0.24; state.k2 = -0.10; state.zoom = 1.15; state.centerX = 0.5; state.centerY = 0.5; k1.value = state.k1; k2.value = state.k2; zoom.value = state.zoom; centerX.value = 0.5; centerY.value = 0.5; }); resetLensBtn.addEventListener('click', ()=>{ state.k1 = 0; state.k2 = 0; state.zoom = 1; state.fishAmount=0; state.fishZoom=1; state.centerX=0.5; state.centerY=0.5; k1.value=0; k2.value=0; zoom.value=1; fishAmount.value=0; fishZoom.value=1; centerX.value=0.5; centerY.value=0.5; }); // Watermarks wmAI.addEventListener('change', ()=> state.wmAI = wmAI.checked ); wmBody.addEventListener('change', ()=> state.wmBody = wmBody.checked ); wmText.addEventListener('input', ()=> state.wmText = wmText.value); bindRange(wmSize, 'wmSize'); bindRange(wmAlpha, 'wmAlpha'); wmColor.addEventListener('input', ()=> state.wmColor = wmColor.value); wmPos.addEventListener('change', ()=> state.wmPos = wmPos.value); wmImg.addEventListener('change', ()=>{ const f = wmImg.files && wmImg.files[0]; if(!f) { state.wmImg = null; return; } const url = URL.createObjectURL(f); const img = new Image(); img.onload = ()=>{ state.wmImg = img; URL.revokeObjectURL(url); }; img.src = url; }); bindRange(wmImgScale, 'wmImgScale'); bindRange(wmImgAlpha, 'wmImgAlpha'); wmImgPos.addEventListener('change', ()=> state.wmImgPos = wmImgPos.value); // Play/Pause playPauseBtn.addEventListener('click', ()=>{ if (!state.src || !state.isVideo) return; if (state.playing){ state.src.pause(); state.playing = false; playPauseBtn.textContent = 'Play'; }else{ state.src.play().then(()=>{ state.playing = true; playPauseBtn.textContent = 'Pause'; }); } }); // Export PNG exportPngBtn.addEventListener('click', ()=>{ if (!finalCanvas.width || !finalCanvas.height) return; finalCanvas.toBlob(b=>{ const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'lenslab.png'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 2000); }, 'image/png', 1.0); }); // Recording (WebM) startRecBtn.addEventListener('click', ()=>{ if (state.recording) return; const stream = finalCanvas.captureStream(30); const mr = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' }); state.mediaRecorder = mr; state.recordedChunks = []; mr.ondataavailable = e=>{ if (e.data.size>0) state.recordedChunks.push(e.data); }; mr.onstop = ()=>{ const blob = new Blob(state.recordedChunks, { type: 'video/webm' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'lenslab.webm'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 3000); updateStatus('Recording saved'); }; mr.start(); state.recording = true; startRecBtn.disabled = true; stopRecBtn.disabled = false; updateStatus('Recording…','warn'); }); stopRecBtn.addEventListener('click', ()=>{ if (!state.recording || !state.mediaRecorder) return; state.mediaRecorder.stop(); state.recording=false; startRecBtn.disabled = false; stopRecBtn.disabled = true; }); // Shift + drag to set center let draggingCenter = false; canvasWrap.addEventListener('pointerdown', (e)=>{ if (!e.shiftKey) return; draggingCenter = true; canvasWrap.setPointerCapture(e.pointerId); setCenterFromEvent(e); }); canvasWrap.addEventListener('pointermove', (e)=>{ if (!draggingCenter) return; setCenterFromEvent(e); }); canvasWrap.addEventListener('pointerup', ()=> draggingCenter=false); function setCenterFromEvent(e){ const rect = finalCanvas.getBoundingClientRect(); const x = (e.clientX - rect.left) / rect.width; const y = (e.clientY - rect.top) / rect.height; state.centerX = Math.min(1, Math.max(0, x)); state.centerY = Math.min(1, Math.max(0, y)); centerX.value = state.centerX; centerY.value = state.centerY; } // Render loop function render(){ requestAnimationFrame(render); if (!state.src) { // draw checker or leave blank return; } // Update texture from source gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, tex); if (state.isVideo){ try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, state.src); } catch(e){} }else{ try { gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, state.src); } catch(e){} } // Uniforms gl.uniform2f(uTexRes, state.width, state.height); gl.uniform2f(uCenter, state.centerX, state.centerY); gl.uniform1f(uK1, state.k1); gl.uniform1f(uK2, state.k2); gl.uniform1f(uZoom, state.zoom); gl.uniform1f(uFishAmt, state.fishAmount); gl.uniform1f(uFishZoom, state.fishZoom); let modeVal = 0.0; if (state.mode === 'barrel') modeVal = 1.0; else if (state.mode === 'fisheye') modeVal = 2.0; gl.uniform1f(uMode, modeVal); // Draw gl.drawArrays(gl.TRIANGLES, 0, 6); // Composite into final canvas outCtx.clearRect(0,0,finalCanvas.width, finalCanvas.height); outCtx.drawImage(glCanvas, 0, 0, finalCanvas.width, finalCanvas.height); // Overlays drawOverlays(outCtx, finalCanvas.width, finalCanvas.height); } function drawOverlays(ctx, W, H){ // Text WM if (state.wmText && state.wmText.trim().length){ ctx.save(); ctx.globalAlpha = state.wmAlpha; ctx.font = `600 ${state.wmSize}px Inter,system-ui,Arial`; ctx.fillStyle = state.wmColor; ctx.textBaseline = 'bottom'; const pad = Math.max(8, Math.round(state.wmSize*0.35)); const metrics = ctx.measureText(state.wmText); const tw = metrics.width, th = state.wmSize + 6; let x=0,y=0; positionBox(state.wmPos, W,H, tw+pad*2, th+pad*1.2, (xx,yy)=>{x=xx;y=yy;}); // Background subtle ctx.fillStyle = 'rgba(0,0,0,0.4)'; roundRect(ctx, x, y, tw+pad*2, th+pad*1.2, 8); ctx.fill(); // Text ctx.fillStyle = state.wmColor; ctx.fillText(state.wmText, x+pad, y + th); ctx.restore(); } // Image WM if (state.wmImg){ const img = state.wmImg; const scale = state.wmImgScale; const maxW = W * 0.35; let drawW = Math.min(maxW, img.naturalWidth) * scale; let drawH = drawW * (img.naturalHeight / img.naturalWidth); ctx.save(); ctx.globalAlpha = state.wmImgAlpha; let x=0,y=0; positionBox(state.wmImgPos, W,H, drawW, drawH, (xx,yy)=>{x=xx;y=yy;}); ctx.drawImage(img, x, y, drawW, drawH); ctx.restore(); } // AI-style watermark (generic) if (state.wmAI){ const label = 'AI GENERATED'; ctx.save(); const size = Math.max(14, Math.round(Math.min(W,H)*0.028)); ctx.font = `700 ${size}px Inter,system-ui,Arial`; const pad = Math.round(size*0.6); const tw = ctx.measureText(label).width; const boxW = tw + pad*2, boxH = size + pad*1.1; const margin = Math.round(Math.min(W,H)*0.03); const x = W - boxW - margin; const y = H - boxH - margin; // glassy box ctx.fillStyle = 'rgba(20,25,36,0.65)'; roundRect(ctx, x, y, boxW, boxH, 10); ctx.fill(); ctx.strokeStyle = 'rgba(122,162,255,0.5)'; ctx.lineWidth = 1; roundRect(ctx, x, y, boxW, boxH, 10); ctx.stroke(); // little grid dots ctx.globalAlpha = 0.4; ctx.fillStyle = '#7aa2ff'; for(let gx= x+10; gx<x+boxW-10; gx+=10){ for(let gy= y+10; gy<y+boxH-10; gy+=10){ ctx.fillRect(gx, gy, 1.2, 1.2); } } ctx.globalAlpha = 1.0; ctx.fillStyle = '#eaf1ff'; ctx.textBaseline = 'bottom'; ctx.fillText(label, x+pad, y+boxH-pad*0.4); ctx.restore(); } // Bodycam-style overlay (generic) if (state.wmBody){ ctx.save(); const barH = Math.round(Math.min(W,H)*0.075); // Top bar ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(0, 0, W, barH); ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.beginPath(); ctx.moveTo(0, barH+0.5); ctx.lineTo(W, barH+0.5); ctx.stroke(); // Text on top bar const titleSize = Math.round(barH*0.42); ctx.font = `700 ${titleSize}px Inter,system-ui,Arial`; ctx.fillStyle = '#e8edf7'; ctx.textBaseline = 'middle'; ctx.fillText('BODYCAM-STYLE', 14, barH/2); // ID & REC const smallSize = Math.round(barH*0.35); ctx.font = `600 ${smallSize}px Inter,system-ui,Arial`; const idText = 'ID: 123456'; const recText = 'REC'; const recW = ctx.measureText(recText).width; ctx.fillStyle = '#e8edf7'; const pad = 12; ctx.fillText(idText, W - pad - recW - 80, barH/2); // Red dot + REC const recX = W - pad - recW; const recY = barH/2; ctx.fillStyle = '#ff4b57'; ctx.beginPath(); ctx.arc(recX - 16, recY, 6, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#e8edf7'; ctx.fillText(recText, recX, recY); // Timestamp bottom-left const bottomH = Math.round(Math.min(W,H)*0.09); const tsY = H - 8; ctx.font = `600 ${Math.round(bottomH*0.38)}px Inter,system-ui,Arial`; ctx.textBaseline = 'alphabetic'; ctx.fillStyle = '#e8edf7'; const ts = formatTimestamp(); ctx.fillText(ts, 12, tsY); ctx.restore(); } } function roundRect(ctx, x,y,w,h,r){ ctx.beginPath(); const rr = Math.min(r, w/2, h/2); ctx.moveTo(x+rr, y); ctx.arcTo(x+w, y, x+w, y+h, rr); ctx.arcTo(x+w, y+h, x, y+h, rr); ctx.arcTo(x, y+h, x, y, rr); ctx.arcTo(x, y, x+w, y, rr); ctx.closePath(); } function positionBox(pos, W,H, boxW, boxH, cb){ const m = Math.round(Math.min(W,H)*0.02); let x=0,y=0; if (pos === 'tr'){ x = W - boxW - m; y = m; } else if (pos === 'tl'){ x = m; y = m; } else if (pos === 'br'){ x = W - boxW - m; y = H - boxH - m; } else if (pos === 'bl'){ x = m; y = H - boxH - m; } else { x = (W-boxW)/2; y = (H-boxH)/2; } cb(x,y); } function formatTimestamp(){ // If video, we can use currentTime offset; else use current date let date = new Date(); if (state.isVideo && state.src){ // Use relative starting from 2024-01-01 00:00:00 just for demo const base = new Date('2024-01-01T00:00:00Z'); const t = base.getTime() + (state.src.currentTime*1000); date = new Date(t); } const yyyy = date.getFullYear(); const MM = String(date.getMonth()+1).padStart(2,'0'); const dd = String(date.getDate()).padStart(2,'0'); const hh = String(date.getHours()).padStart(2,'0'); const mm = String(date.getMinutes()).padStart(2,'0'); const ss = String(date.getSeconds()).padStart(2,'0'); return `${yyyy}/${MM}/${dd} ${hh}:${mm}:${ss}`; } // Responsive sizing: maintain canvas pixel-size as source but scale visually to container width const ro = new ResizeObserver(()=>{ // Visual scaling only; pixel size stays as source w/h // finalCanvas is css-scaled to 100% width by style }); ro.observe(canvasWrap); // Start loop render(); // Initial text watermark to showcase state.wmText = 'Demo Watermark'; wmText.value = state.wmText; updateStatus('Ready'); // ---------------------- // GitHub Pages tips: // - Save this file as index.html in a repo // - Enable Pages (Settings -> Pages -> Deploy from branch) // - Open the URL and drag/drop your media // ---------------------- </script></body> </html>
